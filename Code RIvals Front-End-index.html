<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Code Rivals - C++ Challenge</title>
<style>
    /* Your existing CSS goes here. No changes needed to CSS. */
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@500&display=swap');

    body {
      margin: 0;
      padding: 0;
      background: radial-gradient(circle at center, #001f3f, #000);
      font-family: 'Orbitron', sans-serif;
      color: #00ccff;
      display: flex;
      flex-direction: column;
      align-items: center;
      height: 100vh;
      overflow: hidden;
    }

    h1 {
      text-shadow: 0 0 10px #00ccff;
      margin: 20px 0 10px;
      font-size: 32px;
    }

    .game-container {
      position: relative;
      width: 800px;
      height: 600px;
      border: 2px solid #00ccff;
      border-radius: 20px;
      box-shadow: 0 0 30px #00ccff inset;
      background-color: rgba(0, 0, 50, 0.9);
      overflow: hidden;
      margin-top: 10px;
    }

    /* Shared button style for back button */
    #backToLobbyBtn, #soloBackToLobbyBtn {
      position: absolute;
      padding: 8px 16px;
      background-color: #001f3f;
      border: 2px solid #00ccff;
      color: #00ccff;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 0 10px #00ccff;
      z-index: 10;
      border-radius: 8px;
      top: 10px;
      left: 10px; /* Positioned on the left side */
    }

    .player-circle {
      position: absolute;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .player {
      position: absolute;
      width: 100px;
      text-align: center;
      transform: translate(-50%, -50%);
    }

    .player .name {
      font-weight: bold;
      font-size: 16px;
    }

    .player .name.active {
      color: yellow;
      text-shadow: 0 0 10px yellow;
    }

    .player .name.correct {
      color: lime;
      text-shadow: 0 0 10px lime;
    }

    .player .name.wrong {
      color: red;
      text-shadow: 0 0 10px red;
    }

    .player .lives {
      font-size: 12px;
    }

    #timer {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      text-shadow: 0 0 10px #00ccff;
    }

    #questionBox {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(0,0,50,0.7);
      padding: 20px;
      border: 2px solid #00ccff;
      border-radius: 10px;
      box-shadow: 0 0 10px #00ccff;
      width: 70%;
      text-align: center;
    }

    #questionBox input[type="text"] {
      padding: 10px;
      font-size: 16px;
      width: 60%;
      background-color: black;
      color: #00ccff;
      border: 1px solid #00ccff;
      border-radius: 5px;
      margin-right: 10px;
    }

    #questionBox button {
      padding: 10px 20px;
      background-color: #001f3f;
      border: 2px solid #00ccff;
      color: #00ccff;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 0 10px #00ccff;
      border-radius: 5px;
    }

    .replay-button {
      margin-top: 20px;
      display: none;
    }

    #leaderboard, #globalLeaderboard {
      margin-top: 20px;
      width: 800px;
      background-color: rgba(0,0,0,0.85);
      border: 3px solid #00ccff;
      border-radius: 20px;
      padding: 10px;
      color: #00ccff;
      font-size: 14px;
      font-weight: bold;
      text-align: center;
      box-shadow: 0 0 15px #00ccff;
    }

    #leaderboard table, #globalLeaderboard table {
      width: 100%;
      border-collapse: collapse;
      font-family: 'Orbitron', sans-serif;
    }

    #leaderboard th, #leaderboard td, #globalLeaderboard th, #globalLeaderboard td {
      padding: 12px 10px;
      border: 1px solid #00ccff;
    }

    #leaderboard thead, #globalLeaderboard thead {
      background-color: #000;
      color: #00ccff;
      font-size: 18px;
      text-shadow: 0 0 5px #00ccff;
    }

    #leaderboard tbody tr:nth-child(odd), #globalLeaderboard tbody tr:nth-child(odd) {
      background-color: rgba(0, 0, 50, 0.6);
    }

    #leaderboard tbody tr:nth-child(even), #globalLeaderboard tbody tr:nth-child(even) {
      background-color: rgba(0, 0, 100, 0.4);
    }

    #leaderboard tbody td, #globalLeaderboard tbody td {
      font-size: 16px;
    }

    /* Styles for Game Mode Selection */
    #gameModeSelection {
      display: none; /* Hidden by default, shown after login */
      background-color: rgba(0,0,50,0.9);
      border: 2px solid #00ccff;
      border-radius: 20px;
      padding: 20px;
      width: 600px;
      text-align: center;
      box-shadow: 0 0 20px #00ccff;
      margin-top: 50px;
      justify-content: center;
      gap: 20px;
    }

    .game-mode-box {
      flex: 1;
      background-color: #001f3f;
      border: 2px solid #00ccff;
      border-radius: 15px;
      padding: 30px;
      cursor: pointer;
      transition: transform 0.2s, box-shadow 0.2s;
    }

    .game-mode-box:hover {
      transform: translateY(-5px);
      box-shadow: 0 0 25px #00ccff;
    }

    .game-mode-box h3 {
      margin-top: 0;
      color: #00ccff;
      text-shadow: 0 0 8px #00ccff;
    }


    #gameUI {
      display: none;
      flex-direction: column;
      align-items: center;
      margin-top: 10px;
    }

    /* New styles for chat box */
    .main-content-wrapper {
      display: none; /* Hidden by default, shown when gameUI is active */
      gap: 20px; /* Space between game UI and chat */
      width: fit-content; /* Adjust width to fit content */
      justify-content: center;
      align-items: flex-start; /* Align items to the top */
    }

    #chatBox {
      background-color: rgba(0, 0, 50, 0.9);
      border: 2px solid #00ccff;
      border-radius: 10px;
      box-shadow: 0 0 20px #00ccff;
      width: 300px; /* Fixed width for chat */
      height: 600px; /* Match game container height */
      margin-top: 10px;
      padding: 15px;
      display: flex;
      flex-direction: column;
    }

    #chatMessages {
      flex-grow: 1;
      overflow-y: auto;
      border: 1px solid #00ccff;
      border-radius: 5px;
      padding: 10px;
      margin-bottom: 10px;
      background-color: rgba(0, 0, 0, 0.5);
      color: #00ccff;
      font-size: 14px;
      word-wrap: break-word; /* Ensure long words wrap */
    }

    #chatInput {
      padding: 8px;
      font-size: 14px;
      background-color: black;
      color: #00ccff;
      border: 1px solid #00ccff;
      border-radius: 5px;
      width: calc(100% - 16px); /* Account for padding */
      margin-bottom: 5px;
    }

    #sendChatBtn {
      padding: 8px 15px;
      background-color: #001f3f;
      border: 2px solid #00ccff;
      color: #00ccff;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 0 10px #00ccff;
      border-radius: 5px;
      width: 100%;
    }

    /* Solo Challenge UI Styles */
    #soloChallengeUI {
      display: none; /* Hidden by default */
      flex-direction: column;
      align-items: center;
      background-color: rgba(0,0,50,0.9);
      border: 2px solid #00ccff;
      border-radius: 20px;
      box-shadow: 0 0 30px #00ccff inset;
      padding: 20px;
      width: 800px; /* Same width as game-container for consistency */
      height: 600px; /* Adjusted height for content */
      margin-top: 10px;
      position: relative;
    }

    #soloChallengeUI h2 {
      color: #00ccff;
      text-shadow: 0 0 8px #00ccff;
      margin-top: 0;
    }

    #soloProblemDescription {
      background-color: rgba(0,0,0,0.7);
      border: 1px solid #00ccff;
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
      width: calc(100% - 30px);
      min-height: 80px;
      overflow-y: auto;
      font-size: 16px;
    }

    #soloCodeEditor {
      width: calc(100% - 20px);
      height: 200px;
      background-color: #000;
      color: #00ff00; /* Green text for code editor */
      border: 1px solid #00ccff;
      border-radius: 5px;
      padding: 10px;
      font-family: 'Courier New', monospace;
      font-size: 14px;
      resize: vertical; /* Allow vertical resizing */
      margin-bottom: 15px;
    }

    #soloChallengeButtons {
      display: flex;
      gap: 15px;
      margin-bottom: 15px;
    }

    #soloChallengeButtons button {
      padding: 12px 25px;
      background-color: #001f3f;
      border: 2px solid #00ccff;
      color: #00ccff;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 0 10px #00ccff;
      border-radius: 8px;
      transition: background-color 0.2s, box-shadow 0.2s;
    }

    #soloChallengeButtons button:hover:not(:disabled) {
      background-color: #003f6f;
      box-shadow: 0 0 15px #00ff00;
    }

    #soloChallengeButtons button:disabled {
      cursor: not-allowed;
      opacity: 0.5;
    }

    #soloLoadingIndicator {
          display: none; /* Hidden by default */
          text-align: center;
          margin-top: 10px;
          font-size: 18px;
          color: yellow;
    }

    #soloResult {
      background-color: rgba(0,0,0,0.7);
      border: 1px solid #00ccff;
      border-radius: 8px;
      padding: 15px;
      width: calc(100% - 30px);
      min-height: 80px;
      overflow-y: auto;
      font-size: 14px;
      white-space: pre-wrap; /* Preserve whitespace and wrap text */
    }


    /* Custom Modal for Alerts */
    .custom-modal {
          display: none; /* Hidden by default */
          position: fixed; /* Stay in place */
          z-index: 20; /* Sit on top */
          left: 0;
          top: 0;
          width: 100%; /* Full width */
          height: 100%;
          overflow: auto;
          background-color: rgba(0,0,0,0.8);
          display: flex;
          justify-content: center;
          align-items: center;
    }

    .custom-modal-content {
          background-color: rgba(0,0,50,0.95);
          margin: auto;
          padding: 30px;
          border: 3px solid #00ccff;
          border-radius: 15px;
          width: 80%;
          max-width: 400px;
          text-align: center;
          box-shadow: 0 0 25px #00ccff;
          transform: scale(0.95);
          animation: modalFadeIn 0.3s forwards;
          color: #fff;
    }

    .custom-modal-content h3 {
          color: #00ccff;
          text-shadow: 0 0 10px #00ccff;
          margin-top: 0;
          margin-bottom: 20px;
          font-size: 24px;
    }

    .custom-modal-content p {
          font-size: 16px;
          margin-bottom: 25px;
          line-height: 1.5;
    }

    .custom-modal-content button {
          background-color: #001f3f;
          border: 2px solid #00ccff;
          color: #00ccff;
          padding: 10px 25px;
          border-radius: 8px;
          cursor: pointer;
          font-weight: bold;
          box-shadow: 0 0 10px #00ccff;
          transition: background-color 0.2s, box-shadow 0.2s;
    }

    .custom-modal-content button:hover {
          background-color: #003f6f;
          box-shadow: 0 0 15px #00ff00;
    }

    @keyframes modalFadeIn {
          from { opacity: 0; transform: scale(0.8); }
          to { opacity: 1; transform: scale(1); }
    }

    /* Login/Signup Forms */
    #authContainer {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background-color: rgba(0,0,50,0.9);
      border: 2px solid #00ccff;
      border-radius: 20px;
      padding: 30px;
      width: 400px;
      text-align: center;
      box-shadow: 0 0 25px #00ccff;
      margin-top: 50px;
    }

    #authContainer h2 {
      color: #00ccff;
      text-shadow: 0 0 8px #00ccff;
      margin-top: 0;
      margin-bottom: 25px;
    }

    #authContainer input[type="text"],
    #authContainer input[type="password"] {
      width: calc(100% - 20px);
      padding: 12px;
      margin-bottom: 15px;
      background-color: black;
      color: #00ccff;
      border: 1px solid #00ccff;
      border-radius: 5px;
      font-size: 16px;
    }

    #authContainer button {
      width: 100%;
      padding: 12px;
      background-color: #001f3f;
      border: 2px solid #00ccff;
      color: #00ccff;
      font-weight: bold;
      cursor: pointer;
      box-shadow: 0 0 10px #00ccff;
      border-radius: 8px;
      font-size: 18px;
      transition: background-color 0.2s, box-shadow 0.2s;
      margin-bottom: 10px;
    }

    #authContainer button:hover {
      background-color: #003f6f;
      box-shadow: 0 0 15px #00ff00;
    }

    #authSwitch {
      color: #00ccff;
      text-decoration: underline;
      cursor: pointer;
      font-size: 14px;
      margin-top: 15px;
    }

    /* Logout Button in Main UI (will be shown after login) */
    #logoutBtn {
          position: absolute; /* Or relative to its container, depends on layout */
          top: 10px; /* Adjust as needed */
          right: 10px; /* Adjust as needed */
          padding: 8px 16px;
          background-color: #a00000; /* Red color for logout */
          border: 2px solid #ff0000;
          color: #fff;
          font-weight: bold;
          cursor: pointer;
          box-shadow: 0 0 10px #ff0000;
          z-index: 10;
          border-radius: 8px;
          display: none; /* Hidden by default */
    }

    #welcomeMessage {
          color: #fff;
          font-size: 18px;
          margin-top: 10px;
          display: none; /* Hidden by default */
    }

</style>
</head>
<body>
<h1>Code Rivals</h1>

<button id="logoutBtn" onclick="logout()">Logout</button>
<div id="welcomeMessage"></div>

<div id="authContainer">
    <h2 id="authTitle">Login</h2>
    <input type="text" id="usernameInput" placeholder="Username" autocomplete="username">
    <input type="password" id="passwordInput" placeholder="Password" autocomplete="current-password">
    <button id="authSubmitBtn" onclick="login()">Login</button>
    <div id="authSwitch" onclick="toggleAuthMode()">Don't have an account? Sign Up</div>
</div>


<div id="gameModeSelection">
    <h2>Choose Your Game Mode</h2>
    <div class="game-mode-box" onclick="selectGameMode('4v4-qna')">
        <h3>4v4 Q&A</h3>
        <p>Compete with up to 4 players in a fast-paced Q&A challenge.</p>
    </div>
    <div class="game-mode-box" onclick="selectGameMode('1v1-fill-in-blanks')">
        <h3>1v1 Fill in the Blanks</h3>
        <p>A head-to-head battle, filling in missing code for C++ beginners.</p>
    </div>
    <div class="game-mode-box" onclick="selectGameMode('solo-coding-challenge')">
        <h3>Solo Coding Challenge</h3>
        <p>Improve your skills by solving C++ problems, evaluated by AI.</p>
    </div>
</div>

<div class="main-content-wrapper">
    <div id="gameUI">
      <div class="game-container">
        <button id="backToLobbyBtn" onclick="backToLobby()">Back to Lobby</button>
        <div class="player-circle" id="playerCircle"></div>
        <div id="timer">30</div>
        <div id="questionBox">
          <p id="question">Loading...</p>
          <input type="text" id="answerInput" placeholder="Your answer here" />
          <button id="submitAnswerBtn" onclick="submitAnswer()">Submit</button>
        </div>
      </div>

      <div id="leaderboard">
        <h2>Current Round Leaderboard</h2>
        <table>
          <thead>
            <tr><th>Rank</th><th>Player</th><th>ELO</th></tr>
          </thead>
          <tbody id="leaderboardBody"></tbody>
        </table>
      </div>

      <div id="globalLeaderboard">
        <h2>Global Leaderboard (All Players)</h2>
        <table>
          <thead>
            <tr><th>Rank</th><th>Player</th><th>ELO</th></tr>
          </thead>
          <tbody id="globalLeaderboardBody"></tbody>
        </table>
      </div>
      <div class="replay-button" id="replayButton">
        <button onclick="replayGame()">Replay</button>
      </div>
    </div>

    <div id="soloChallengeUI">
        <button id="soloBackToLobbyBtn" onclick="backToLobby()">Back to Lobby</button>
        <h2>Solo Coding Challenge - Stage <span id="soloCurrentStage">1</span></h2>
        <div id="soloProblemDescription"></div>
        <textarea id="soloCodeEditor" placeholder="Write your C++ code here..."></textarea>
        <div id="soloChallengeButtons">
            <button id="soloPrevStageBtn" onclick="previousSoloStage()" disabled>Previous Stage</button>
            <button onclick="submitSoloCode()">Run Code</button>
            <button id="soloNextStageBtn" onclick="nextSoloStage()" disabled>Next Stage</button>
        </div>
        <div id="soloLoadingIndicator">Evaluating code...</div>
        <div id="soloResult"></div>
    </div>


    <div id="chatBox">
        <h3>Lobby Chat</h3>
        <div id="chatMessages"></div>
        <input type="text" id="chatInput" placeholder="Type your message..." />
        <button id="sendChatBtn" onclick="sendMessage()">Send</button>
    </div>
</div>

<div id="customModal" class="custom-modal">
    <div class="custom-modal-content">
        <h3 id="modalTitle"></h3>
        <p id="modalMessage"></p>
        <button onclick="closeModal()">OK</button>
    </div>
</div>

<script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>

<script>
    // IMPORTANT: Replace this with your actual Render backend URL
    const BACKEND_URL = "YOUR_RENDER_BACKEND_URL_HERE"; // e.g., "https://code-rivals-backend.onrender.com"
    const socket = io(BACKEND_URL); // Initialize Socket.IO connection

    let currentUser = null; // Will hold { username, soloStage, elo } fetched from backend

    let players = []; // Stores current game's player objects (local representation)
    let currentGameMode = '';

    const originalQuestions = [
      { q: "What is the output of: cout << 2 + 2;", a: "4" },
      { q: "Which keyword is used for constant?", a: "const" },
      { q: "How many bytes is an int?", a: "4" },
      { q: "C++ pointer access operator?", a: "->" },
      { q: "Declare a pointer to int", a: "int* ptr;" }
    ];

    const fillInBlanksQuestions = [
      { q: "int main() { cout << \"Hello, ___\"; return 0; }", a: "world", hint: "Common greeting" },
      { q: "int ___ = 10;", a: "x", hint: "A common variable name" },
      { q: "for (int i = 0; i < ___; i++)", a: "10", hint: "A typical loop limit" },
      { q: "class MyClass { public: MyClass() { /* constructor */ } };", a: "MyClass", hint: "Name of the class" },
      { q: "std::string ___ = \"C++\";", a: "language", hint: "What is C++?" }
    ];

    const soloChallenges = [
      {
        stage: 1,
        title: "Hello World!",
        problem: "Write a C++ program that prints 'Hello, World!' to the console. The output must exactly match 'Hello, World!' followed by a newline.",
        expectedOutput: "Hello, World!\n",
        initialCode: `#include <iostream>

int main() {
  // Your code here
  return 0;
}`
      },
      {
        stage: 2,
        title: "Add Two Numbers",
        problem: "Write a C++ program that declares two integer variables, `a` and `b`, initializes them to 5 and 7 respectively, and prints their sum to the console. The output must be exactly '12' followed by a newline.",
        expectedOutput: "12\n",
        initialCode: `#include <iostream>

int main() {
  int a = 5;
  int b = 7;
  // Your code here
  std::cout << (a + b) << std::endl;
  return 0;
}`
      },
      {
        stage: 3,
        title: "Conditional Statement (If-Else)",
        problem: "Write a C++ program that declares an integer variable `num` and initializes it to 10. If `num` is greater than 5, print 'Greater than 5'; otherwise, print 'Not greater than 5'. The output must be exactly 'Greater than 5' followed by a newline.",
        expectedOutput: "Greater than 5\n",
        initialCode: `#include <iostream>

int main() {
  int num = 10;
  // Your if-else statement here
  if (num > 5) {
    std::cout << "Greater than 5" << std::endl;
  } else {
    std::cout << "Not greater than 5" << std::endl;
  }
  return 0;
}`
      },
      {
        stage: 4,
        title: "Simple Loop (For loop)",
        problem: "Write a C++ program that uses a for loop to print numbers from 1 to 3, each on a new line. The output must be exactly '1\\n2\\n3\\n'.",
        expectedOutput: "1\n2\n3\n",
        initialCode: `#include <iostream>

int main() {
  // Your for loop here
  for (int i = 1; i <= 3; ++i) {
    std::cout << i << std::endl;
  }
  return 0;
}`
      },
      {
        stage: 5,
        title: "Basic Function",
        problem: "Write a C++ program with a function named `add` that takes two integers as parameters and returns their sum. In `main`, call `add` with 15 and 20 and print the result. The output must be exactly '35' followed by a newline.",
        expectedOutput: "35\n",
        initialCode: `#include <iostream>

// Your add function here
int add(int a, int b) {
  return a + b;
}

int main() {
  // Call your function and print the result
  std::cout << add(15, 20) << std::endl;
  return 0;
}`
      },
      {
        stage: 6,
        title: "Factorial Calculation",
        problem: "Write a C++ program to calculate the factorial of a number (e.g., 5). Print the result. The output must be exactly '120' followed by a newline. (Factorial of 5 is 5*4*3*2*1 = 120)",
        expectedOutput: "120\n",
        initialCode: `#include <iostream>

int main() {
  int n = 5;
  long long factorial = 1; // Use long long for larger factorials

  // Calculate factorial
  for (int i = 1; i <= n; ++i) {
    factorial *= i;
  }

  std::cout << factorial << std::endl;
  return 0;
}`
      },
      {
        stage: 7,
        title: "Array Sum",
        problem: "Write a C++ program that initializes an integer array with values {10, 20, 30}. Calculate the sum of its elements and print the sum. The output must be exactly '60' followed by a newline.",
        expectedOutput: "60\n",
        initialCode: `#include <iostream>
#include <vector> // Using vector is often preferred in modern C++

int main() {
  // Using a C-style array:
  // int arr[] = {10, 20, 30};

  // Or using std::vector:
  std::vector<int> numbers = {10, 20, 30};
  int sum = 0;

  // Calculate sum
  for (int num : numbers) {
    sum += num;
  }

  std::cout << sum << std::endl;
  return 0;
}`
      }
    ];

    let questions = []; // Used for Q&A and Fill-in-the-blanks
    let currentQuestionIndex = 0;
    let currentPlayerIndex = 0; // Represents the local player's turn in simulated multiplayer
    let timeLeft = 30;
    let timer;

    let currentSoloStage = 0; // This will be loaded from currentUser.soloStage

    // --- Utility Functions ---

    // Custom Modal Functions
    function showCustomModal(title, message) {
        document.getElementById('modalTitle').textContent = title;
        document.getElementById('modalMessage').textContent = message;
        document.getElementById('customModal').style.display = 'flex';
    }

    function closeModal() {
        document.getElementById('customModal').style.display = 'none';
    }

    // --- Authentication Functions ---
    let isLoginMode = true; // true for login, false for signup

    function toggleAuthMode() {
      isLoginMode = !isLoginMode;
      const authTitle = document.getElementById('authTitle');
      const authSubmitBtn = document.getElementById('authSubmitBtn');
      const authSwitch = document.getElementById('authSwitch');

      if (isLoginMode) {
        authTitle.textContent = "Login";
        authSubmitBtn.textContent = "Login";
        authSubmitBtn.onclick = login;
        authSwitch.textContent = "Don't have an account? Sign Up";
      } else {
        authTitle.textContent = "Sign Up";
        authSubmitBtn.textContent = "Sign Up";
        authSubmitBtn.onclick = signup;
        authSwitch.textContent = "Already have an account? Login";
      }
    }

    async function signup() {
      const username = document.getElementById('usernameInput').value.trim();
      const password = document.getElementById('passwordInput').value.trim();

      if (!username || !password) {
        showCustomModal("Error", "Username and password cannot be empty.");
        return;
      }

      try {
        const response = await fetch(`${BACKEND_URL}/api/signup`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ username, password })
        });
        const data = await response.json();

        if (response.ok) { // Check if HTTP status is 2xx
          showCustomModal("Success", `Account for "${username}" created! Please login.`);
          toggleAuthMode(); // Switch to login mode
          document.getElementById('usernameInput').value = username; // Pre-fill username
          document.getElementById('passwordInput').value = ''; // Clear password field
        } else {
          showCustomModal("Error", data.message || "Signup failed. Please try again.");
        }
      } catch (error) {
        console.error('Signup fetch error:', error);
        showCustomModal("Error", "Network error. Could not connect to the server.");
      }
    }

    async function login() {
      const username = document.getElementById('usernameInput').value.trim();
      const password = document.getElementById('passwordInput').value.trim();

      if (!username || !password) {
        showCustomModal("Error", "Please enter username and password.");
        return;
      }

      try {
        const response = await fetch(`${BACKEND_URL}/api/login`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ username, password })
        });
        const data = await response.json();

        if (response.ok) { // Check if HTTP status is 2xx
          currentUser = data.user; // Load user data from backend
          showCustomModal("Success", `Welcome, ${currentUser.username}!`);
          document.getElementById('authContainer').style.display = 'none';
          document.getElementById('gameModeSelection').style.display = 'flex';
          document.getElementById('logoutBtn').style.display = 'block'; // Show logout button
          document.getElementById('welcomeMessage').textContent = `Logged in as: ${currentUser.username}`;
          document.getElementById('welcomeMessage').style.display = 'block';

          // Emit player connected event to Socket.IO for real-time presence
          socket.emit('player_connected', { username: currentUser.username, elo: currentUser.elo });
          // Request global leaderboard data
          socket.emit('request_global_leaderboard');

        } else {
          showCustomModal("Error", data.message || "Login failed. Invalid username or password.");
        }
      } catch (error) {
        console.error('Login fetch error:', error);
        showCustomModal("Error", "Network error. Could not connect to the server.");
      }
    }

    async function logout() {
      if (currentUser) {
        // Attempt to save current user's soloStage and ELO to the backend before logging out
        try {
          const response = await fetch(`${BACKEND_URL}/api/update-user-data`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
              username: currentUser.username,
              soloStage: currentUser.soloStage,
              elo: currentUser.elo
            })
          });
          const data = await response.json();
          if (response.ok) {
            console.log("User data saved successfully on logout:", data.message);
          } else {
            console.error("Error saving user data on logout:", data.message);
          }
        } catch (error) {
          console.error("Network error saving user data on logout:", error);
        }

        // Emit player disconnected event to Socket.IO
        socket.emit('player_disconnected', { username: currentUser.username });
      }

      currentUser = null; // Clear current user session
      if (timer) clearInterval(timer); // Stop any active game timer

      // Hide game elements and show login
      document.getElementById('gameModeSelection').style.display = 'none';
      document.querySelector('.main-content-wrapper').style.display = 'none';
      document.getElementById('gameUI').style.display = 'none';
      document.getElementById('soloChallengeUI').style.display = 'none';
      document.getElementById('chatBox').style.display = 'none';
      document.getElementById('logoutBtn').style.display = 'none';
      document.getElementById('welcomeMessage').style.display = 'none';

      // Show authentication container
      document.getElementById('authContainer').style.display = 'flex';
      document.getElementById('usernameInput').value = '';
      document.getElementById('passwordInput').value = '';
      showCustomModal("Logged Out", "You have been logged out.");

      // Reset game state for next login
      players = [];
      currentGameMode = '';
      currentQuestionIndex = 0;
      currentPlayerIndex = 0;
      timeLeft = 30;
      currentSoloStage = 0; // Reset this for the next login to ensure it loads from stored user data
    }


    // --- Game Mode Selection & Navigation ---
    function selectGameMode(mode) {
      if (!currentUser) {
        showCustomModal("Access Denied", "Please log in to play.");
        return;
      }

      currentGameMode = mode;
      document.getElementById("gameModeSelection").style.display = "none";
      document.querySelector('.main-content-wrapper').style.display = "flex";

      // Initialize based on mode
      if (currentGameMode === '4v4-qna' || currentGameMode === '1v1-fill-in-blanks') {
        document.getElementById("gameUI").style.display = "flex";
        document.getElementById("soloChallengeUI").style.display = "none";
        document.getElementById("chatBox").style.display = "flex"; // Show chat for multiplayer

        // Reset current user's lives for a new game mode instance
        // ELO is managed by the backend
        currentUser.lives = 3;

        // Populate initial players array for local display (bots are simulated)
        if (currentGameMode === '4v4-qna') {
            players = [
              { name: currentUser.username, lives: currentUser.lives, elo: currentUser.elo, socketId: socket.id },
              { name: "Bot 1", lives: 3, elo: 1000 },
              { name: "Bot 2", lives: 3, elo: 1000 },
              { name: "Bot 3", lives: 3, elo: 1000 }
            ];
            questions = [...originalQuestions];
        } else { // 1v1-fill-in-blanks
            players = [
              { name: currentUser.username, lives: currentUser.lives, elo: currentUser.elo, socketId: socket.id },
              { name: "Opponent Bot", lives: 3, elo: 1000 }
            ];
            questions = [...fillInBlanksQuestions];
        }
        startGame(); // Start multiplayer game simulation
        // In a real multiplayer setup, you'd emit an event to the server to join a room
        // e.g., socket.emit('join_game_lobby', { mode: currentGameMode });
      } else if (currentGameMode === 'solo-coding-challenge') {
        document.getElementById("gameUI").style.display = "none";
        document.getElementById("soloChallengeUI").style.display = "flex";
        document.getElementById("chatBox").style.display = "none"; // Hide chat for solo mode

        // For solo mode, initialize currentSoloStage from currentUser's data
        currentSoloStage = currentUser.soloStage;
        startSoloChallenge(); // Start solo challenge
      }

      updateLeaderboard(); // Update leaderboards for multiplayer modes initially
      // In a true multiplayer, leaderboard would be driven by server updates
    }

    function backToLobby() {
      // Stop any ongoing timers/game loops
      if (timer) clearInterval(timer);

      // Attempt to save current user's soloStage and ELO to the backend before going back to lobby
      if (currentUser) {
        fetch(`${BACKEND_URL}/api/update-user-data`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            username: currentUser.username,
            soloStage: currentUser.soloStage,
            elo: currentUser.elo
          })
        })
        .then(response => response.json())
        .then(data => {
            if (data.message) console.log("User data saved:", data.message);
        })
        .catch(error => console.error("Error saving user data on back to lobby:", error));
      }

      // Hide all game UIs and show game mode selection
      document.querySelector('.main-content-wrapper').style.display = "none";
      document.getElementById("gameUI").style.display = "none";
      document.getElementById("soloChallengeUI").style.display = "none";
      document.getElementById("chatBox").style.display = "none"; // Hide chat when in lobby selection
      document.getElementById("gameModeSelection").style.display = "flex";

      // Clear game-specific UI elements
      document.getElementById("question").textContent = "Loading...";
      document.getElementById("answerInput").value = "";
      document.getElementById("answerInput").disabled = false;
      document.getElementById("submitAnswerBtn").disabled = false; // Ensure submit button is re-enabled
      document.getElementById("replayButton").style.display = "none";
      document.getElementById("leaderboardBody").innerHTML = "";

      // Clear solo challenge UI elements (but preserve currentUser.soloStage)
      document.getElementById("soloProblemDescription").innerHTML = "";
      document.getElementById("soloCodeEditor").value = "";
      document.getElementById("soloResult").textContent = "";
      document.getElementById("soloLoadingIndicator").style.display = "none";
      document.getElementById("soloNextStageBtn").disabled = true;
      document.getElementById("soloPrevStageBtn").disabled = true; // Ensure prev button is reset too

      // Request global leaderboard data again when returning to lobby (if it's displayed)
      socket.emit('request_global_leaderboard');
    }

    // --- Multiplayer Game Logic (Q&A / Fill-in-the-Blanks - Still client-side simulation with bots) ---
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    function placePlayers() {
      const container = document.getElementById("playerCircle");
      const centerX = container.clientWidth / 2;
      const centerY = container.clientHeight / 2;
      const radius = 200;
      container.innerHTML = "";

      players.forEach((player, index) => {
        const angle = (2 * Math.PI / players.length) * index - Math.PI / 2;
        const x = centerX + radius * Math.cos(angle);
        const y = centerY + radius * Math.sin(angle);

        const playerDiv = document.createElement("div");
        playerDiv.className = "player";
        playerDiv.id = `player${player.name.replace(/\s/g, '')}`; // Use player name for unique ID
        playerDiv.style.left = `${x}px`;
        playerDiv.style.top = `${y}px`;

        const nameDiv = document.createElement("div");
        nameDiv.className = "name";
        nameDiv.textContent = player.name;

        const livesDiv = document.createElement("div");
        livesDiv.className = "lives";
        livesDiv.textContent = `Lives: ${player.lives}`;

        playerDiv.appendChild(nameDiv);
        playerDiv.appendChild(livesDiv);
        container.appendChild(playerDiv);
      });
      highlightCurrentPlayer();
    }

    function updateTimer() {
      document.getElementById("timer").textContent = timeLeft;
    }

    function countdown() {
      timeLeft--;
      updateTimer();

      if (timeLeft <= 0) {
        clearInterval(timer);
        handleAnswer(false); // Time's up, incorrect answer
      }
    }

    function highlightCurrentPlayer() {
      players.forEach((player, index) => {
        const playerDiv = document.getElementById(`player${player.name.replace(/\s/g, '')}`);
        if (playerDiv) {
          const nameDiv = playerDiv.querySelector('.name');
          nameDiv.classList.remove('active', 'correct', 'wrong');
          if (index === currentPlayerIndex) {
            nameDiv.classList.add('active');
          }
        }
      });
    }

    function showQuestion() {
      if (currentQuestionIndex >= questions.length || players.filter(p => p.lives > 0).length <= 1) {
        endGame();
        return;
      }

      shuffleArray(players); // Shuffle players each round to change turn order
      currentPlayerIndex = 0; // Reset current player for the new round
      highlightCurrentPlayer();

      const questionData = questions[currentQuestionIndex];
      let displayQuestion = questionData.q;
      if (currentGameMode === '1v1-fill-in-blanks' && questionData.hint) {
        displayQuestion += ` (Hint: ${questionData.hint})`;
      }

      document.getElementById("question").textContent = displayQuestion;
      document.getElementById("answerInput").value = "";
      document.getElementById("answerInput").disabled = false;
      document.getElementById("submitAnswerBtn").disabled = false;

      timeLeft = 30;
      updateTimer();
      clearInterval(timer);
      timer = setInterval(countdown, 1000);

      // Simulate bot answers after a delay
      setTimeout(simulateBotAnswer, Math.random() * 5000 + 2000); // Bots answer between 2-7 seconds
    }

    function handleAnswer(isCorrect) {
      clearInterval(timer); // Stop timer immediately
      const currentPlayer = players[currentPlayerIndex];
      const playerDiv = document.getElementById(`player${currentPlayer.name.replace(/\s/g, '')}`);
      const nameDiv = playerDiv ? playerDiv.querySelector('.name') : null;

      if (!currentPlayer) return;

      if (isCorrect) {
        if (nameDiv) nameDiv.classList.add('correct');
        currentPlayer.elo += 50; // Award ELO for correct answer
        showCustomModal("Correct!", `${currentPlayer.name} answered correctly!`);
      } else {
        if (nameDiv) nameDiv.classList.add('wrong');
        currentPlayer.lives--;
        currentPlayer.elo = Math.max(0, currentPlayer.elo - 25); // Deduct ELO for incorrect/timeout
        showCustomModal("Incorrect!", `${currentPlayer.name} answered incorrectly or timed out! ${currentPlayer.name} now has ${currentPlayer.lives} lives.`);
      }

      // Update lives display
      if (playerDiv) {
        playerDiv.querySelector('.lives').textContent = `Lives: ${currentPlayer.lives}`;
      }

      // Update current user's ELO if they are the player
      if (currentPlayer.name === currentUser.username) {
          currentUser.elo = currentPlayer.elo;
      }

      // Remove player if out of lives
      if (currentPlayer.lives <= 0) {
        players = players.filter(p => p.name !== currentPlayer.name);
        if (playerDiv) playerDiv.remove(); // Remove player from UI
        showCustomModal("Eliminated!", `${currentPlayer.name} has been eliminated!`);
      }

      updateLeaderboard(); // Always update leaderboard after an action

      // Move to next question after a short delay
      setTimeout(() => {
        currentQuestionIndex++;
        if (players.filter(p => p.lives > 0).length > 1) {
          showQuestion();
        } else {
          endGame();
        }
      }, 3000); // 3-second pause before next question
    }

    function submitAnswer() {
      if (!currentUser) {
          showCustomModal("Error", "Please log in to submit answers.");
          return;
      }

      const answerInput = document.getElementById("answerInput");
      const userAnswer = answerInput.value.trim();
      const correctAnswer = questions[currentQuestionIndex].a;

      // Only the current player (user) can submit, others are bots
      const currentPlayer = players[currentPlayerIndex];

      // If the current active player is not the actual user logged in,
      // it means a bot is supposed to answer or it's not the user's turn.
      // This is for local simulation only.
      if (currentPlayer.name !== currentUser.username) {
        showCustomModal("Not Your Turn", "It's not your turn to answer!");
        answerInput.value = ""; // Clear input
        return;
      }


      if (userAnswer.toLowerCase() === correctAnswer.toLowerCase()) {
        handleAnswer(true);
      } else {
        handleAnswer(false);
      }

      document.getElementById("answerInput").disabled = true;
      document.getElementById("submitAnswerBtn").disabled = true;
    }

    function simulateBotAnswer() {
      // Find the currently active player (it might be a bot if currentPlayerIndex isn't the user)
      const currentPlayer = players[currentPlayerIndex];

      // If the current player is the user, don't simulate a bot answer for them
      if (currentPlayer && currentPlayer.name === currentUser.username) {
        return;
      }

      // If no current player or current player is eliminated, skip
      if (!currentPlayer || currentPlayer.lives <= 0) {
        return;
      }

      const currentQ = questions[currentQuestionIndex];
      const botAnswerChance = Math.random();

      // Bots get smarter over time or based on mode
      let successRate = 0.6; // 60% chance to answer correctly

      if (currentGameMode === '1v1-fill-in-blanks') {
          successRate = 0.5; // Slightly harder for bots in 1v1 fill-in-blanks
      }

      if (botAnswerChance < successRate) {
        // Bot answers correctly
        // In a real multiplayer, this would be a server-side decision/response
        handleAnswer(true);
      } else {
        // Bot answers incorrectly or times out
        handleAnswer(false);
      }
    }


    function updateLeaderboard() {
        const leaderboardBody = document.getElementById("leaderboardBody");
        leaderboardBody.innerHTML = "";

        // Sort players by ELO (descending)
        const sortedPlayers = [...players].sort((a, b) => b.elo - a.elo);

        sortedPlayers.forEach((player, index) => {
            const row = leaderboardBody.insertRow();
            row.insertCell(0).textContent = index + 1; // Rank
            row.insertCell(1).textContent = player.name;
            row.insertCell(2).textContent = player.elo;
        });
    }

    function updateGlobalLeaderboard(globalPlayers) {
        const globalLeaderboardBody = document.getElementById("globalLeaderboardBody");
        globalLeaderboardBody.innerHTML = "";

        // Sort global players by ELO (descending)
        const sortedGlobalPlayers = [...globalPlayers].sort((a, b) => b.elo - a.elo);

        sortedGlobalPlayers.forEach((player, index) => {
            const row = globalLeaderboardBody.insertRow();
            row.insertCell(0).textContent = index + 1; // Rank
            row.insertCell(1).textContent = player.username; // Use username from global data
            row.insertCell(2).textContent = player.elo;
        });
    }

    function startGame() {
        // Ensure player circles are redrawn for the new game
        placePlayers();
        shuffleArray(questions); // Shuffle questions for each new game instance
        currentQuestionIndex = 0;
        document.getElementById("replayButton").style.display = "none";
        showQuestion();
    }

    function endGame() {
      clearInterval(timer);
      document.getElementById("question").textContent = "Game Over!";
      document.getElementById("answerInput").disabled = true;
      document.getElementById("submitAnswerBtn").disabled = true;
      document.getElementById("replayButton").style.display = "block";

      const remainingPlayers = players.filter(p => p.lives > 0);
      if (remainingPlayers.length === 1) {
          showCustomModal("Game Over!", `${remainingPlayers[0].name} wins!`);
      } else if (remainingPlayers.length === 0) {
          showCustomModal("Game Over!", "No one survived!");
      } else {
          showCustomModal("Game Over!", "All questions answered!");
      }

      // In a real multiplayer, game results and ELO updates would be sent to server
      // and server would update global leaderboard.
      // For now, just update the global leaderboard display from server via socket.io
      socket.emit('request_global_leaderboard');
    }

    function replayGame() {
        // Reset game state for replay
        currentQuestionIndex = 0;
        currentPlayerIndex = 0;
        timeLeft = 30;

        // Reset players for a new game, including the current user's lives and ELO
        if (currentGameMode === '4v4-qna') {
            players = [
              { name: currentUser.username, lives: 3, elo: currentUser.elo, socketId: socket.id },
              { name: "Bot 1", lives: 3, elo: 1000 },
              { name: "Bot 2", lives: 3, elo: 1000 },
              { name: "Bot 3", lives: 3, elo: 1000 }
            ];
            questions = [...originalQuestions];
        } else { // 1v1-fill-in-blanks
            players = [
              { name: currentUser.username, lives: 3, elo: currentUser.elo, socketId: socket.id },
              { name: "Opponent Bot", lives: 3, elo: 1000 }
            ];
            questions = [...fillInBlanksQuestions];
        }
        startGame();
    }


    // --- Solo Challenge Logic ---

    function startSoloChallenge() {
        if (soloChallenges.length === 0) {
            document.getElementById("soloProblemDescription").textContent = "No solo challenges available.";
            return;
        }

        // Ensure currentSoloStage doesn't exceed available challenges, or go below 0
        currentSoloStage = Math.max(0, Math.min(currentUser.soloStage, soloChallenges.length - 1));

        displaySoloChallenge(currentSoloStage);
    }

    function displaySoloChallenge(stageIndex) {
        if (stageIndex < 0 || stageIndex >= soloChallenges.length) {
            showCustomModal("Information", "No more challenges available.");
            return;
        }

        const challenge = soloChallenges[stageIndex];
        document.getElementById("soloCurrentStage").textContent = challenge.stage;
        document.getElementById("soloProblemDescription").textContent = challenge.problem;
        document.getElementById("soloCodeEditor").value = challenge.initialCode;
        document.getElementById("soloResult").textContent = ""; // Clear previous result

        // Update button states
        document.getElementById("soloPrevStageBtn").disabled = (stageIndex === 0);
        // User can only go to next stage if they've completed the current one (i.e., their saved soloStage is higher)
        document.getElementById("soloNextStageBtn").disabled = (currentUser.soloStage <= stageIndex || stageIndex >= soloChallenges.length - 1);
    }

    function previousSoloStage() {
        if (currentSoloStage > 0) {
            currentSoloStage--;
            displaySoloChallenge(currentSoloStage);
        }
    }

    function nextSoloStage() {
        // Allow advancing only if the user has completed the current stage
        if (currentSoloStage < currentUser.soloStage && currentSoloStage < soloChallenges.length - 1) {
            currentSoloStage++;
            displaySoloChallenge(currentSoloStage);
        } else {
            showCustomModal("Information", "Complete the current stage before moving to the next!");
        }
    }

    async function submitSoloCode() {
        if (!currentUser) {
            showCustomModal("Error", "Please log in to submit code.");
            return;
        }

        const currentChallenge = soloChallenges[currentSoloStage];
        const userCode = document.getElementById("soloCodeEditor").value;

        document.getElementById("soloLoadingIndicator").style.display = "block";
        document.getElementById("soloChallengeButtons").querySelectorAll('button').forEach(btn => btn.disabled = true);
        document.getElementById("soloResult").textContent = "Evaluating...";

        try {
            const response = await fetch(`${BACKEND_URL}/api/gemini-proxy`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    prompt: currentChallenge.problem,
                    currentCode: userCode,
                    expectedOutput: currentChallenge.expectedOutput
                })
            });

            const data = await response.json();

            document.getElementById("soloResult").textContent = data.evaluation || "Evaluation failed.";

            if (data.success && data.evaluation.includes("Correct!")) {
                showCustomModal("Success", `Stage ${currentChallenge.stage} Complete!`);
                // Only advance soloStage if they completed the current highest stage
                if (currentUser.soloStage === currentChallenge.stage) {
                    currentUser.soloStage++; // Advance user's overall progress
                    currentUser.elo += 75; // Award ELO for solo completion
                    // Save updated soloStage and ELO to the backend
                    await fetch(`${BACKEND_URL}/api/update-user-data`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ username: currentUser.username, soloStage: currentUser.soloStage, elo: currentUser.elo })
                    });
                    // Request global leaderboard update
                    socket.emit('request_global_leaderboard');
                }
                // Re-enable next stage button if applicable
                document.getElementById("soloNextStageBtn").disabled = (currentUser.soloStage <= currentSoloStage || currentSoloStage >= soloChallenges.length - 1);

            } else {
                showCustomModal("Try Again", "Your code needs some adjustments. Check the output for hints.");
            }
        } catch (error) {
            console.error("Error submitting solo code:", error);
            document.getElementById("soloResult").textContent = "An error occurred during evaluation.";
            showCustomModal("Error", "Could not connect to the evaluation server or AI.");
        } finally {
            document.getElementById("soloLoadingIndicator").style.display = "none";
            document.getElementById("soloChallengeButtons").querySelectorAll('button').forEach(btn => btn.disabled = false);
            // Re-evaluate button states
            document.getElementById("soloPrevStageBtn").disabled = (currentSoloStage === 0);
            document.getElementById("soloNextStageBtn").disabled = (currentUser.soloStage <= currentSoloStage || currentSoloStage >= soloChallenges.length - 1);
        }
    }


    // --- Socket.IO Event Listeners (Real-time communication) ---
    socket.on('connect', () => {
        console.log('Connected to backend Socket.IO server!');
        // If a user is already logged in (e.g., after refreshing the page while logged in),
        // send their presence to the server.
        if (currentUser && currentUser.username) {
            socket.emit('player_connected', { username: currentUser.username, elo: currentUser.elo, socketId: socket.id });
        }
    });

    socket.on('disconnect', () => {
        console.log('Disconnected from backend Socket.IO server.');
    });

    socket.on('chat message', (msg) => {
        const chatMessagesDiv = document.getElementById('chatMessages');
        const msgElement = document.createElement('div');
        msgElement.textContent = msg;
        chatMessagesDiv.appendChild(msgElement);
        chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight; // Auto-scroll to bottom
    });

    socket.on('chat history', (messages) => {
        const chatMessagesDiv = document.getElementById('chatMessages');
        chatMessagesDiv.innerHTML = ''; // Clear previous history
        messages.forEach(msg => {
            const msgElement = document.createElement('div');
            msgElement.textContent = msg;
            chatMessagesDiv.appendChild(msgElement);
        });
        chatMessagesDiv.scrollTop = chatMessagesDiv.scrollHeight;
    });

    // Handle global leaderboard updates from the server
    socket.on('global_leaderboard_update', (leaderboardData) => {
        updateGlobalLeaderboard(leaderboardData);
    });

    // Add this when the page loads, to potentially log in automatically or show auth
    document.addEventListener('DOMContentLoaded', () => {
        // Initial setup for UI visibility
        document.getElementById('gameModeSelection').style.display = 'none';
        document.querySelector('.main-content-wrapper').style.display = 'none';
        document.getElementById('gameUI').style.display = 'none';
        document.getElementById('soloChallengeUI').style.display = 'none';
        document.getElementById('chatBox').style.display = 'none';
        document.getElementById('logoutBtn').style.display = 'none';
        document.getElementById('welcomeMessage').style.display = 'none';
        document.getElementById('authContainer').style.display = 'flex'; // Show auth by default
    });


    // Function to send chat messages
    function sendMessage() {
        const chatInput = document.getElementById('chatInput');
        const message = chatInput.value.trim();
        if (message && currentUser && currentUser.username) {
            socket.emit('chat message', { username: currentUser.username, message: message });
            chatInput.value = ''; // Clear input
        } else if (!currentUser) {
            showCustomModal("Error", "You must be logged in to chat.");
        } else if (!message) {
             showCustomModal("Error", "Message cannot be empty.");
        }
    }

</script>
</body>
</html>
